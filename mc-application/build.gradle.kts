
plugins {
    id("buildlogic.java-application-conventions")
    id("buildlogic.versioning")     // reads version.txt file to acquire this app's version number
    id("application")
    id("distribution")              // builds a distribution of the application for the homebrew tap
    alias(libs.plugins.shadow.jar)  // builds runnable jar containing all dependencies; use for local testing
    alias(libs.plugins.versions)    // checks for newer versions of dependencies
    alias(libs.plugins.lombok)
}

dependencies {
    implementation(project(":mc-annotations"))
    implementation(project(":mc-common"))
    implementation(project(":mc-adapter-spring-spi"))
    implementation(project(":mc-generator-spring"))

    implementation(libs.picocli.spring.boot.starter)
    implementation(libs.spring.context)
    implementation(libs.spring.core)
    implementation(libs.spring.boot.starter.logging)
    implementation(libs.guava)
    implementation(libs.commonsConfig)

    testImplementation(libs.junit.jupiter)
    testImplementation(libs.assertJ)
    testImplementation(libs.mockito)
    testImplementation(libs.spring.boot.starter.test)
    testRuntimeOnly(libs.junit.platform.launcher)
}

application {
    // Define the main class for the application.
    mainClass = "mmm.coffee.metacode.Application"
}

/**
 * ----------------------------------------------------------------
 * When the distribution tar/zip file is the published artifact,
 * a jar is included for each module: the tar/zip file contains
 * a 'lib/meta-annotations-x.y.z.jar, lib/meta-cli-x.y.z.jar,
 * lib/meta-common-x.y.z.jar, and so on. The gist is, there's no
 * primary MANIFEST.MF file like the one found in an uber jar
 * (as generated by shadowjar). PicoCLI expects to find _some_
 * MANIFEST file that reveals the implementation-version of
 * MetaCode. This block creates that MANIFEST file and places it
 * in the meta-cli-x.y.z.jar's manifest.
 * ---------------------------------------------------------------- */
tasks.named<Jar>("jar") {
    archiveBaseName.set(application.applicationName)
    // This line isn't absolutely necessary in the manifest, but it's nice to know.
    // manifest.attributes["Main-Class"] = "mmm.coffee.metacode.Application"
    manifest.attributes["Implementation-Title"] = "MetaCode"
    manifest.attributes["Implementation-Version"] = archiveVersion.getOrElse("0.1")
}

